import { CurveFactory } from "d3-shape";
import { action, computed, makeObservable, observable, reaction } from "mobx";
import { ConnectionBase, getUID, NodeBase } from "rete";

import { Editor } from "../editor";
import { BaseNode } from "../nodes/base";

type StringKeyof<T> = Extract<keyof T, string>;

type NODEID = string;
type SOCKET_KEY = string;

export class Connection<
  Source extends BaseNode<any, any, any> = BaseNode<any, any, any>,
  Target extends BaseNode<any, any, any> = BaseNode<any, any, any>,
> implements ConnectionBase
{
  /**
   * Connection id, unique string generated by `getUID` function
   */
  id: ConnectionBase["id"];
  /**
   * Source node id
   */
  source: NodeBase["id"];
  /**
   * Target node id
   */
  target: NodeBase["id"];

  curve?: CurveFactory;
  isLoop?: boolean;
  isMagnetic?: boolean;

  /**
   * @constructor
   * @param source Source node instance
   * @param sourceOutput Source node output key
   * @param target Target node instance
   * @param targetInput Target node input key
   */

  sourceValue?: any = undefined;
  targetValue?: any = undefined;

  sourceNode: BaseNode<any, any, any, any>;
  targetNode: BaseNode<any, any, any, any>;
  destroy: () => Promise<void>;

  get inSync() {
    return this.sourceValue === this.targetValue;
  }
  get sourceDefintion() {
    return this.sourceNode.snap.context.outputSockets[this.sourceOutput];
  }
  get targetDefintion() {
    return this.targetNode.snap.context.inputSockets[this.targetInput];
  }

  constructor(
    source: Source,
    public sourceOutput: StringKeyof<Source["outputs"]>,
    target: Target,
    public targetInput: StringKeyof<Target["inputs"]>,
    public editor: Editor,
  ) {
    if (!source.outputs[sourceOutput as string]) {
      throw new Error(
        `source node doesn't have output with a key ${String(sourceOutput)}`,
      );
    }
    if (!target.inputs[targetInput as string]) {
      throw new Error(
        `target node doesn't have input with a key ${String(targetInput)}`,
      );
    }
    this.id = getUID();
    this.source = source.id;
    this.target = target.id;

    console.log("connection", this);

    this.sourceNode = this.editor.editor.getNode(source.id);
    this.targetNode = this.editor.editor.getNode(target.id);

    if (
      this.sourceNode.snap.context.outputs &&
      this.sourceNode.snap.context.outputs[sourceOutput]
    ) {
      this.sourceValue = this.sourceNode.snap.context.outputs[sourceOutput];
    }

    this.targetValue =
      this.targetNode.snap.context.inputs[targetInput] ?? undefined;

    this.sourceNode.actor.subscribe((state) => {
      if (
        state.context.outputs === undefined ||
        state.context.outputs[sourceOutput] === undefined
      ) {
        return;
      }
      if (state.context.outputs) {
        [];
      }
      if (this.sourceValue !== state.context.outputs[sourceOutput]) {
        this.setSourceValue(state.context.outputs[sourceOutput]);
      }
    });

    this.targetNode.actor.subscribe((state) => {
      if (this.targetValue !== state.context.inputs[targetInput]) {
        this.setTargetValue(state.context.inputs[targetInput]);
      }
    });

    makeObservable(this, {
      sourceValue: observable,
      targetValue: observable,

      setTargetValue: action,
      setSourceValue: action,

      inSync: computed,
    });

    this.targetNode.actor.send({
      type: "UPDATE_SOCKET",
      params: {
        name: this.targetInput,
        side: "input",
        socket: {
          "x-connection": {
            ...this.targetDefintion?.["x-connection"],
            [this.sourceNode.id]: this.sourceOutput,
          },
        },
      },
    });
    this.sourceNode.actor.send({
      type: "UPDATE_SOCKET",
      params: {
        name: this.sourceOutput,
        side: "output",
        socket: {
          "x-connection": {
            ...this.sourceDefintion?.["x-connection"],
            [this.targetNode.id]: this.targetInput,
          },
        },
      },
    });

    if (!this.inSync) {
      this.sync();
    }

    const a = reaction(
      () => this.sourceValue,
      () => {
        console.log(this.identifier, "source value changed", this.sourceValue);
        if (!this.inSync) {
          this.sync();
        }
      },
    );
    const b = reaction(
      () => this.targetValue,
      () => {
        console.log(this.identifier, "target value changed", this.targetValue);
        if (!this.inSync) {
          this.sync();
        }
      },
    );

    this.destroy = async () => {
      a();
      b();

      const sourceConnections = this.sourceConnections;

      this.sourceNode.actor.send({
        type: "UPDATE_SOCKET",
        params: {
          name: this.sourceOutput,
          side: "output",
          socket: {
            "x-connection": {
              ...sourceConnections,
            },
          },
        },
      });

      const targetConnections = this.targetConnections;

      this.targetNode.actor.send({
        type: "UPDATE_SOCKET",
        params: {
          name: this.targetInput,
          side: "input",
          socket: {
            "x-connection": {
              ...targetConnections,
            },
          },
        },
      });

      if (this.isActorRef) {
        console.log("@@@@", "RESTORING THE REFERENCE", {
          type: "UPDATE_SOCKET",
          params: {
            name: this.targetInput,
            side: "input",
            socket: {
              "x-actor-ref":
                this.targetNode.snap.context.inputSockets[this.targetInput][
                  "x-actor"
                ],
            },
          },
        });

        // this.targetNode.actor.send({
        //   type: "UPDATE_SOCKET",
        //   params: {
        //     name: this.targetInput,
        //     side: "input",
        //     socket: {
        //       "x-actor-ref": undefined,
        //     },
        //   },
        // });

        const childActor = this.targetDefintion?.["x-actor"];

        this.targetNode.actor.send({
          type: "UPDATE_SOCKET",
          params: {
            name: this.targetInput,
            side: "input",
            socket: {
              "x-actor-ref": childActor,
            },
          },
        });
        childActor.send({
          type: "UPDATE_OUTPUTS",
        });

        const targetInput = this.targetNode.inputs[this.targetInput];
        if (targetInput?.control?.id) {
          await this.targetNode.di.area?.update(
            "control",
            targetInput?.control?.id,
          );
        }
        await this.targetNode.di.area?.update("node", this.targetNode.id);
      }
    };
  }

  get sourceConnections(): Record<NODEID, SOCKET_KEY> {
    return this.editor.editor
      .getConnections()
      .filter(
        (connection) =>
          connection.source === this.source &&
          connection.sourceOutput === this.sourceOutput,
      )
      .reduce((acc, connection) => {
        return {
          ...acc,
          [connection.target]: connection.targetInput,
        };
      }, {});
  }

  get targetConnections(): Record<NODEID, SOCKET_KEY> {
    return this.editor.editor
      .getConnections()
      .filter(
        (connection) =>
          connection.target === this.target &&
          connection.targetInput === this.targetInput,
      )
      .reduce((acc, connection) => {
        return {
          ...acc,
          [connection.source]: connection.sourceOutput,
        };
      }, {});
  }

  get identifier() {
    return `${this.sourceNode.label}-${this.sourceOutput}-${this.targetNode.label}-${this.targetInput}`;
  }

  public isActorRef = false;

  public sync() {
    console.log("SYNC");
    const outputDefinitiation =
      this.sourceNode.snap.context.outputSockets[this.sourceOutput];
    const inputDefinition =
      this.targetNode.snap.context.inputSockets[this.targetInput];
    if (
      inputDefinition["x-actor-type"] === this.sourceNode.ID &&
      (!this.isActorRef ||
        inputDefinition["x-actor-ref"] !== this.sourceNode.actor.ref)
    ) {
      console.log("SETTING ACTOR REF");
      this.targetNode.actor.send({
        type: "UPDATE_SOCKET",
        params: {
          name: this.targetInput,
          side: "input",
          socket: {
            "x-actor-ref": this.sourceNode.actor.ref,
          },
        },
      });
      this.isActorRef = true;
    }

    const canSetValue = this.targetNode.snap.can({
      type: "SET_VALUE",
    });
    if (!canSetValue) {
      console.error("cannot set value");
    }
    this.targetNode.actor.send({
      type: "SET_VALUE",
      values: {
        [this.targetInput]: this.sourceValue,
      },
    });
  }

  public setTargetValue(value: any) {
    this.targetValue = value;
  }

  public setSourceValue(value: any) {
    this.sourceValue = value;
  }

  public toJSON() {
    return {
      id: this.id,
      source: this.source,
      target: this.target,
      sourceOutput: this.sourceOutput,
      targetInput: this.targetInput,
    };
  }
}
