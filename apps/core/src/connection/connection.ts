import { CurveFactory } from "d3-shape";
import { action, computed, makeObservable, observable, reaction } from "mobx";
import { ConnectionBase, getUID, NodeBase } from "rete";

import { Editor } from "../editor";
import { BaseNode } from "../nodes/base";

type StringKeyof<T> = Extract<keyof T, string>;

export class Connection<
  Source extends BaseNode<any, any, any> = BaseNode<any, any, any>,
  Target extends BaseNode<any, any, any> = BaseNode<any, any, any>,
> implements ConnectionBase
{
  /**
   * Connection id, unique string generated by `getUID` function
   */
  id: ConnectionBase["id"];
  /**
   * Source node id
   */
  source: NodeBase["id"];
  /**
   * Target node id
   */
  target: NodeBase["id"];

  curve?: CurveFactory;
  isLoop?: boolean;
  isMagnetic?: boolean;

  /**
   * @constructor
   * @param source Source node instance
   * @param sourceOutput Source node output key
   * @param target Target node instance
   * @param targetInput Target node input key
   */

  sourceValue?: any = undefined;
  targetValue?: any = undefined;

  sourceNode: BaseNode<any, any, any, any>;
  targetNode: BaseNode<any, any, any, any>;
  destroy: () => void;

  get inSync() {
    return this.sourceValue === this.targetValue;
  }

  constructor(
    source: Source,
    public sourceOutput: StringKeyof<Source["outputs"]>,
    target: Target,
    public targetInput: StringKeyof<Target["inputs"]>,
    public editor: Editor,
  ) {
    if (!source.outputs[sourceOutput as string]) {
      throw new Error(
        `source node doesn't have output with a key ${String(sourceOutput)}`,
      );
    }
    if (!target.inputs[targetInput as string]) {
      throw new Error(
        `target node doesn't have input with a key ${String(targetInput)}`,
      );
    }
    this.id = getUID();
    this.source = source.id;
    this.target = target.id;

    console.log("connection", this);

    this.sourceNode = this.editor.editor.getNode(source.id);
    this.targetNode = this.editor.editor.getNode(target.id);

    if (
      this.sourceNode.snap.context.outputs &&
      this.sourceNode.snap.context.outputs[sourceOutput]
    ) {
      this.sourceValue = this.sourceNode.snap.context.outputs[sourceOutput];
    }

    this.targetValue =
      this.targetNode.snap.context.inputs[targetInput] ?? undefined;

    this.sourceNode.actor.subscribe((state) => {
      if (
        state.context.outputs === undefined ||
        state.context.outputs[sourceOutput] === undefined
      ) {
        return;
      }
      if (state.context.outputs) {
        [];
      }
      if (this.sourceValue !== state.context.outputs[sourceOutput]) {
        this.setSourceValue(state.context.outputs[sourceOutput]);
      }
    });
    this.targetNode.actor.subscribe((state) => {
      if (this.targetValue !== state.context.inputs[targetInput]) {
        this.setTargetValue(state.context.inputs[targetInput]);
      }
    });

    makeObservable(this, {
      sourceValue: observable,
      targetValue: observable,

      setTargetValue: action,
      setSourceValue: action,

      inSync: computed,
    });

    if (!this.inSync) {
      this.sync();
    }
    const a = reaction(
      () => this.sourceValue,
      () => {
        console.log(this.identifier, "source value changed", this.sourceValue);
        if (!this.inSync) {
          this.sync();
        }
      },
    );
    const b = reaction(
      () => this.targetValue,
      () => {
        console.log(this.identifier, "target value changed", this.targetValue);
        if (!this.inSync) {
          this.sync();
        }
      },
    );

    this.destroy = () => {
      a();
      b();
      if (this.targetInput === "messages") {
        console.log("@@@@", "RESTORING THE REFERENCE", {
          type: "UPDATE_SOCKET",
          params: {
            name: this.targetInput,
            side: "input",
            socket: {
              "x-actor-ref":
                this.targetNode.snap.context.inputSockets[this.targetInput][
                  "x-actor"
                ],
            },
          },
        });

        this.targetNode.actor.send({
          type: "UPDATE_SOCKET",
          params: {
            name: this.targetInput,
            side: "input",
            socket: {
              "x-actor-ref":
                this.targetNode.snap.context.inputSockets[this.targetInput][
                  "x-actor"
                ],
            },
          },
        });
        const targetInput = this.targetNode.inputs[this.targetInput];
        if (targetInput?.control?.id) {
          this.targetNode.di.area?.update("control", targetInput?.control?.id);
        }
        this.targetNode.di.area?.update("node", this.targetNode.id);
      }
    };
  }

  get identifier() {
    return `${this.sourceNode.label}-${this.sourceOutput}-${this.targetNode.label}-${this.targetInput}`;
  }

  public sync() {
    console.log("SYNC");
    const outputDefinitiation =
      this.sourceNode.snap.context.outputSockets[this.sourceOutput];
    const inputDefinition =
      this.targetNode.snap.context.inputSockets[this.targetInput];
    if (inputDefinition["x-actor-type"] === this.sourceNode.ID) {
      this.targetNode.actor.send({
        type: "UPDATE_SOCKET",
        params: {
          name: this.targetInput,
          side: "input",
          socket: {
            "x-actor-ref": this.sourceNode.actor.ref,
          },
        },
      });
    }

    console.log("VALUES ARE NOT MATCHING", {
      type: "SET_VALUE",
      values: {
        [this.targetInput]: this.sourceValue,
      },
    });
    const canSetValue = this.targetNode.snap.can({
      type: "SET_VALUE",
    });
    if (!canSetValue) {
      console.log("cannot set value");
    }
    this.targetNode.actor.send({
      type: "SET_VALUE",
      values: {
        [this.targetInput]: this.sourceValue,
      },
    });
  }

  public setTargetValue(value: any) {
    this.targetValue = value;
  }

  public setSourceValue(value: any) {
    this.sourceValue = value;
  }

  public toJSON() {
    return {
      id: this.id,
      source: this.source,
      target: this.target,
      sourceOutput: this.sourceOutput,
      targetInput: this.targetInput,
    };
  }
}
