import type { CurveFactory } from "d3-shape";
import { get, has, omit } from "lodash-es";
import { action, computed, makeObservable, observable, reaction } from "mobx";
import type { ConnectionBase, NodeBase } from "rete";
import { getUID } from "rete";

import type {
  ActorConfig,
  ConnectionConfigRecord,
  JSONSocket,
} from "../controls/socket-generator";
import type { Editor } from "../editor";
import type { BaseMachine, BaseNode } from "../nodes/base";
import { NodeTypes } from "../types";

type StringKeyof<T> = Extract<keyof T, string>;

type NODEID = string;
type SOCKET_KEY = string;

export class Connection<
  Source extends BaseNode<any, any, any> = BaseNode<any, any, any>,
  Target extends BaseNode<any, any, any> = BaseNode<any, any, any>,
> implements ConnectionBase
{
  /**
   * Connection id, unique string generated by `getUID` function
   */
  id: ConnectionBase["id"];
  /**
   * Source node id
   */
  source: NodeBase["id"];
  /**
   * Target node id
   */
  target: NodeBase["id"];

  curve?: CurveFactory;
  isLoop?: boolean;
  isMagnetic?: boolean;

  /**
   * @constructor
   * @param source Source node instance
   * @param sourceOutput Source node output key
   * @param target Target node instance
   * @param targetInput Target node input key
   */

  sourceValue?: any = undefined;
  targetValue?: any = undefined;

  sourceNode: BaseNode<BaseMachine, any, any, any>;
  targetNode: BaseNode<BaseMachine, any, any, any>;
  destroy: () => Promise<void>;

  get inSync() {
    if (this.isActorRef) {
      return (
        this.targetDefintion?.["x-actor-ref"] === this.sourceNode.actor.ref
      );
    }
    if (this.targetDefintion.type === "tool") {
      // console.log("$$$$ TOOL $$$$", {
      //   targetValue: this.targetValue,
      //   sourceNode: this.sourceNode.toolDefination,
      // });

      for (const [key, value] of Object.entries(
        this.sourceNode.toolDefination,
      )) {
        const hashTarget = JSON.stringify(this.targetValue[key]);
        const hashSource = JSON.stringify(value);

        if (hashTarget !== hashSource) {
          return false;
        }
      }
      return true;
    }

    return this.sourceValue === this.targetValue;
  }
  get sourceDefintion(): JSONSocket {
    return this.sourceNode.snap.context.outputSockets[this.sourceOutput];
  }
  get targetDefintion(): JSONSocket {
    return this.targetNode.snap.context.inputSockets[this.targetInput];
  }

  constructor(
    source: Source,
    public sourceOutput: StringKeyof<Source["outputs"]>,
    target: Target,
    public targetInput: StringKeyof<Target["inputs"]>,
    public editor: Editor,
  ) {
    if (!source.outputs[sourceOutput as string]) {
      throw new Error(
        `source node doesn't have output with a key ${String(sourceOutput)}`,
      );
    }
    if (!target.inputs[targetInput as string]) {
      throw new Error(
        `target node doesn't have input with a key ${String(targetInput)}`,
      );
    }
    this.id = getUID();
    this.source = source.id;
    this.target = target.id;

    console.log("connection", this);

    this.sourceNode = this.editor.editor.getNode(source.id);
    this.targetNode = this.editor.editor.getNode(target.id);

    if (this.sourceNode.snap.context.outputs?.[sourceOutput]) {
      this.sourceValue = this.sourceNode.snap.context.outputs[sourceOutput];
    }

    this.targetValue =
      this.targetNode.snap.context.inputs[targetInput] ?? undefined;

    this.sourceNode.actor.subscribe((state) => {
      if (
        state.context.outputs === undefined ||
        state.context.outputs[sourceOutput] === undefined
      ) {
        return;
      }
      if (state.context.outputs) {
        [];
      }
      if (this.sourceValue !== state.context.outputs[sourceOutput]) {
        this.setSourceValue(state.context.outputs[sourceOutput]);
      }
    });

    this.targetNode.actor.subscribe((state) => {
      if (this.targetValue !== state.context.inputs[targetInput]) {
        this.setTargetValue(state.context.inputs[targetInput]);
      }
    });

    makeObservable(this, {
      sourceValue: observable,
      targetValue: observable,

      setTargetValue: action,
      setSourceValue: action,

      inSync: computed,
    });

    this.targetNode.actor.send({
      type: "UPDATE_SOCKET",
      params: {
        name: this.targetInput,
        side: "input",
        socket: {
          "x-connection": {
            ...this.targetDefintion?.["x-connection"],
            [this.sourceNode.actor.id]: {
              actorRef: this.sourceNode.actor.ref,
              key: this.sourceOutput,
            },
          } as ConnectionConfigRecord,
        },
      },
    });

    this.sourceNode.actor.send({
      type: "UPDATE_SOCKET",
      params: {
        name: this.sourceOutput,
        side: "output",
        socket: {
          "x-connection": {
            ...this.sourceDefintion?.["x-connection"],
            [this.targetNode.actor.id]: {
              actorRef: this.targetNode.actor.ref,
              key: this.targetInput,
            },
          } as ConnectionConfigRecord,
        },
      },
    });

    if (!this.inSync) {
      this.sync();
    }

    this.destroy = async () => {
      const sourceNodeContext = this.sourceNode.actor.getSnapshot().context;
      for (const [key, socket] of Object.entries(
        sourceNodeContext.outputSockets,
      )) {
        if (has(socket["x-connection"], this.targetNode.actor.id)) {
          console.log("CONNECTION TO REMOVE", socket["x-connection"]);
          this.sourceNode.actor.send({
            type: "UPDATE_SOCKET",
            params: {
              name: key,
              side: "output",
              socket: {
                "x-connection": omit(
                  socket["x-connection"],
                  this.targetNode.actor.id,
                ),
              },
            },
          });
        }
      }

      const targetNodeContext = this.targetNode.actor.getSnapshot().context;
      for (const [key, socket] of Object.entries(
        targetNodeContext.inputSockets,
      )) {
        if (has(socket["x-connection"], this.sourceNode.actor.id)) {
          console.log("CONNECTION TO REMOVE", socket["x-connection"]);
          this.targetNode.actor.send({
            type: "UPDATE_SOCKET",
            params: {
              name: key,
              side: "input",
              socket: {
                "x-connection": omit(
                  socket["x-connection"],
                  this.sourceNode.actor.id,
                ),
              },
            },
          });
        }
      }

      if (this.targetDefintion.type === "tool") {
        const keys = Object.keys(this.targetValue).filter((key) =>
          // we omit `node_` for the tool names. here we are putting back to make it work.
          `node_${key}`.startsWith(`${this.source}`),
        );
        const value = omit({ ...this.targetValue }, keys);

        this.targetNode.actor.send({
          type: "SET_VALUE",
          params: {
            values: {
              [this.targetInput]: {
                ...value,
              },
            },
          },
        });
      }

      if (this.isActorRef) {
        console.log("RESTORE");
        const lastUsedInternalActorType = get(this.targetDefintion, [
          "x-actor-ref-type",
        ])!;
        const lastUserInternalActor = get(this.targetDefintion, [
          "x-actor-config",
          lastUsedInternalActorType,
          "actor",
        ]);
        this.targetNode.actor.send({
          type: "UPDATE_SOCKET",
          params: {
            name: this.targetInput,
            side: "input",
            socket: {
              "x-actor-ref": lastUserInternalActor,
              "x-actor-ref-id": lastUserInternalActor.id,
              "x-actor-ref-type": lastUserInternalActor.src as NodeTypes,
              "x-actor-type": lastUserInternalActor.src as NodeTypes,
            },
          },
        });
      }
    };
  }

  get sourceConnections(): Record<NODEID, SOCKET_KEY> {
    return this.editor.editor
      .getConnections()
      .filter(
        (connection) =>
          connection.source === this.source &&
          connection.sourceOutput === this.sourceOutput,
      )
      .reduce((acc, connection) => {
        return {
          ...acc,
          [connection.target]: connection.targetInput,
        };
      }, {});
  }

  get targetConnections(): Record<NODEID, SOCKET_KEY> {
    return this.editor.editor
      .getConnections()
      .filter(
        (connection) =>
          connection.target === this.target &&
          connection.targetInput === this.targetInput,
      )
      .reduce((acc, connection) => {
        return {
          ...acc,
          [connection.source]: connection.sourceOutput,
        };
      }, {});
  }

  get identifier() {
    return `${this.sourceNode.label}-${this.sourceOutput}-${this.targetNode.label}-${this.targetInput}`;
  }

  public isActorRef = false;

  public sync() {
    console.log("SYNC");
    if (
      this.targetDefintion["x-compatible"] &&
      this.targetDefintion["x-compatible"].includes(
        this.sourceDefintion.type,
      ) &&
      (!this.isActorRef ||
        this.targetDefintion["x-actor-ref"] !== this.sourceNode.actor.ref)
    ) {
      this.updateActorReference();
      this.isActorRef = true;
    } else if (this.targetDefintion.type === "tool") {
      this.targetNode.actor.send({
        type: "SET_VALUE",
        params: {
          values: {
            [this.targetInput]: {
              ...this.targetValue,
              ...this.sourceNode.toolDefination,
            },
          },
        },
      });
    } else {
      console.log("DO NOTHING");
    }
  }

  private updateActorReference() {
    this.targetNode.actor.send({
      type: "UPDATE_SOCKET",
      params: {
        name: this.targetInput,
        side: "input",
        socket: {
          "x-actor-ref": this.sourceNode.actor.ref,
          "x-actor-ref-id": this.sourceNode.actor.id,
          "x-actor-ref-type": this.sourceNode.actor.src as NodeTypes,
          "x-actor-type": this.sourceNode.actor.src as NodeTypes,
        },
      },
    });
    const config = get(this.targetDefintion, [
      "x-actor-config",
      this.sourceNode.ID,
    ]) as ActorConfig;
    if (config) {
      for (const [key, value] of Object.entries(config.connections)) {
        this.sourceNode.actor.send({
          type: "UPDATE_SOCKET",
          params: {
            name: key,
            side: "output",
            socket: {
              "x-connection": {
                ...this.sourceDefintion?.["x-connection"],
                [this.targetNode.actor.id]: {
                  actorRef: this.targetNode.actor.ref,
                  key: value,
                },
              } as ConnectionConfigRecord,
            },
          },
        });
      }
    }
  }

  public setTargetValue(value: any) {
    this.targetValue = value;
  }

  public setSourceValue(value: any) {
    this.sourceValue = value;
  }

  public toJSON() {
    return {
      id: this.id,
      source: this.source,
      target: this.target,
      sourceOutput: this.sourceOutput,
      targetInput: this.targetInput,
    };
  }
}
