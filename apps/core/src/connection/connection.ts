import { createId, init } from "@paralleldrive/cuid2";
import type { CurveFactory } from "d3-shape";
import { get, omit } from "lodash-es";
import { action, computed, makeObservable, observable, reaction } from "mobx";
import type { ConnectionBase, NodeBase } from "rete";
import { getUID } from "rete";

import type {
  ActorConfig,
  ConnectionConfigRecord,
  JSONSocket,
} from "../controls/socket-generator";
import type { Editor } from "../editor";
import type { BaseMachine, BaseNode } from "../nodes/base";

type StringKeyof<T> = Extract<keyof T, string>;

type NODEID = string;
type SOCKET_KEY = string;

export class Connection<
  Source extends BaseNode<any, any, any> = BaseNode<any, any, any>,
  Target extends BaseNode<any, any, any> = BaseNode<any, any, any>,
> implements ConnectionBase
{
  /**
   * Connection id, unique string generated by `getUID` function
   */
  id: ConnectionBase["id"];
  /**
   * Source node id
   */
  source: NodeBase["id"];
  /**
   * Target node id
   */
  target: NodeBase["id"];

  curve?: CurveFactory;
  isLoop?: boolean;
  isMagnetic?: boolean;

  /**
   * @constructor
   * @param source Source node instance
   * @param sourceOutput Source node output key
   * @param target Target node instance
   * @param targetInput Target node input key
   */

  sourceValue?: any = undefined;
  targetValue?: any = undefined;

  sourceNode: BaseNode<BaseMachine, any, any, any>;
  targetNode: BaseNode<BaseMachine, any, any, any>;
  destroy: () => Promise<void>;

  get inSync() {
    if (this.isActorRef) {
      return (
        this.targetDefintion?.["x-actor-ref"] === this.sourceNode.actor.ref
      );
    }
    if (this.targetDefintion.type === "tool") {
      // console.log("$$$$ TOOL $$$$", {
      //   targetValue: this.targetValue,
      //   sourceNode: this.sourceNode.toolDefination,
      // });

      for (const [key, value] of Object.entries(
        this.sourceNode.toolDefination,
      )) {
        const hashTarget = JSON.stringify(this.targetValue[key]);
        const hashSource = JSON.stringify(value);

        if (hashTarget !== hashSource) {
          return false;
        }
      }
      return true;
    }

    return this.sourceValue === this.targetValue;
  }
  get sourceDefintion(): JSONSocket {
    return this.sourceNode.snap.context.outputSockets[this.sourceOutput];
  }
  get targetDefintion(): JSONSocket {
    return this.targetNode.snap.context.inputSockets[this.targetInput];
  }

  constructor(
    source: Source,
    public sourceOutput: StringKeyof<Source["outputs"]>,
    target: Target,
    public targetInput: StringKeyof<Target["inputs"]>,
    public editor: Editor,
  ) {
    if (!source.outputs[sourceOutput as string]) {
      throw new Error(
        `source node doesn't have output with a key ${String(sourceOutput)}`,
      );
    }
    if (!target.inputs[targetInput as string]) {
      throw new Error(
        `target node doesn't have input with a key ${String(targetInput)}`,
      );
    }
    this.id = getUID();
    this.source = source.id;
    this.target = target.id;

    console.log("connection", this);

    this.sourceNode = this.editor.editor.getNode(source.id);
    this.targetNode = this.editor.editor.getNode(target.id);

    if (this.sourceNode.snap.context.outputs?.[sourceOutput]) {
      this.sourceValue = this.sourceNode.snap.context.outputs[sourceOutput];
    }

    this.targetValue =
      this.targetNode.snap.context.inputs[targetInput] ?? undefined;

    this.sourceNode.actor.subscribe((state) => {
      if (
        state.context.outputs === undefined ||
        state.context.outputs[sourceOutput] === undefined
      ) {
        return;
      }
      if (state.context.outputs) {
        [];
      }
      if (this.sourceValue !== state.context.outputs[sourceOutput]) {
        this.setSourceValue(state.context.outputs[sourceOutput]);
      }
    });

    this.targetNode.actor.subscribe((state) => {
      if (this.targetValue !== state.context.inputs[targetInput]) {
        this.setTargetValue(state.context.inputs[targetInput]);
      }
    });

    makeObservable(this, {
      sourceValue: observable,
      targetValue: observable,

      setTargetValue: action,
      setSourceValue: action,

      inSync: computed,
    });

    this.targetNode.actor.send({
      type: "UPDATE_SOCKET",
      params: {
        name: this.targetInput,
        side: "input",
        socket: {
          "x-connection": {
            ...this.targetDefintion?.["x-connection"],
            [this.sourceNode.id]: {
              actorRef: this.sourceNode.actor.ref,
              key: this.sourceOutput,
            },
          } as ConnectionConfigRecord,
        },
      },
    });

    this.sourceNode.actor.send({
      type: "UPDATE_SOCKET",
      params: {
        name: this.sourceOutput,
        side: "output",
        socket: {
          "x-connection": {
            ...this.sourceDefintion?.["x-connection"],
            [this.targetNode.id]: {
              actorRef: this.targetNode.actor.ref,
              key: this.targetInput,
            },
          } as ConnectionConfigRecord,
        },
      },
    });

    if (!this.inSync) {
      this.sync();
    }

    const a = reaction(
      () => this.sourceValue,
      () => {
        console.log(this.identifier, "source value changed", this.sourceValue);
        if (!this.inSync) {
          this.sync();
        }
      },
    );
    const b = reaction(
      () => this.targetValue,
      () => {
        console.log(this.identifier, "target value changed", this.targetValue);
        if (!this.inSync) {
          this.sync();
        }
      },
    );

    this.destroy = async () => {
      a();
      b();

      const sourceConnections = this.sourceConnections;

      this.sourceNode.actor.send({
        type: "UPDATE_SOCKET",
        params: {
          name: this.sourceOutput,
          side: "output",
          socket: {
            "x-connection": {
              ...sourceConnections,
            },
          },
        },
      });

      const targetConnections = this.targetConnections;

      this.targetNode.actor.send({
        type: "UPDATE_SOCKET",
        params: {
          name: this.targetInput,
          side: "input",
          socket: {
            "x-connection": {
              ...targetConnections,
            },
          },
        },
      });

      if (this.targetDefintion.type === "tool") {
        const keys = Object.keys(this.targetValue).filter((key) =>
          // we omit `node_` for the tool names. here we are putting back to make it work.
          `node_${key}`.startsWith(`${this.source}`),
        );
        const value = omit({ ...this.targetValue }, keys);

        this.targetNode.actor.send({
          type: "SET_VALUE",
          params: {
            values: {
              [this.targetInput]: {
                ...value,
              },
            },
          },
        });
      }

      if (this.isActorRef) {
        console.log("@@@@", "RESTORING THE REFERENCE", {
          type: "UPDATE_SOCKET",
          params: {
            name: this.targetInput,
            side: "input",
            socket: {
              "x-actor-ref":
                this.targetNode.snap.context.inputSockets[this.targetInput][
                  "x-actor"
                ],
            },
          },
        });

        const childActor = this.targetDefintion?.["x-actor"];

        this.targetNode.actor.send({
          type: "UPDATE_SOCKET",
          params: {
            name: this.targetInput,
            side: "input",
            socket: {
              "x-actor-ref": childActor,
            },
          },
        });
        childActor.send({
          type: "UPDATE_OUTPUTS",
        });

        const targetInput = this.targetNode.inputs[this.targetInput];
        if (targetInput?.control?.id) {
          await this.targetNode.di.area?.update(
            "control",
            targetInput?.control?.id,
          );
        }
        await this.targetNode.di.area?.update("node", this.targetNode.id);
      }
    };
  }

  get sourceConnections(): Record<NODEID, SOCKET_KEY> {
    return this.editor.editor
      .getConnections()
      .filter(
        (connection) =>
          connection.source === this.source &&
          connection.sourceOutput === this.sourceOutput,
      )
      .reduce((acc, connection) => {
        return {
          ...acc,
          [connection.target]: connection.targetInput,
        };
      }, {});
  }

  get targetConnections(): Record<NODEID, SOCKET_KEY> {
    return this.editor.editor
      .getConnections()
      .filter(
        (connection) =>
          connection.target === this.target &&
          connection.targetInput === this.targetInput,
      )
      .reduce((acc, connection) => {
        return {
          ...acc,
          [connection.source]: connection.sourceOutput,
        };
      }, {});
  }

  get identifier() {
    return `${this.sourceNode.label}-${this.sourceOutput}-${this.targetNode.label}-${this.targetInput}`;
  }

  public isActorRef = false;

  public sync() {
    console.log("SYNC");
    if (
      this.targetDefintion["x-compatible"] &&
      this.targetDefintion["x-compatible"].includes(
        this.sourceDefintion.type,
      ) &&
      (!this.isActorRef ||
        this.targetDefintion["x-actor-ref"] !== this.sourceNode.actor.ref)
    ) {
      this.updateActorReference();
      this.sourceNode.actor.send({
        type: "UPDATE_OUTPUTS",
      });
      this.isActorRef = true;
    } else if (this.targetDefintion.type === "tool") {
      this.targetNode.actor.send({
        type: "SET_VALUE",
        params: {
          values: {
            [this.targetInput]: {
              ...this.targetValue,
              ...this.sourceNode.toolDefination,
            },
          },
        },
      });
    } else if (!this.isActorRef) {
      const canSetValue = this.targetNode.snap.can({
        type: "SET_VALUE",
      });
      if (!canSetValue) {
        console.error("cannot set value");
      }
      this.targetNode.actor.send({
        type: "SET_VALUE",
        params: {
          values: {
            [this.targetInput]: this.sourceValue,
          },
        },
      });
    } else {
      console.log("DO NOTHING");
    }
  }

  private updateActorReference() {
    console.log("UPDATE ACTOR REFERENCE");
    this.targetNode.actor.send({
      type: "UPDATE_SOCKET",
      params: {
        name: this.targetInput,
        side: "input",
        socket: {
          "x-actor-ref": this.sourceNode.actor.ref,
        },
      },
    });
    const config = get(this.targetDefintion, [
      "x-actor-config",
      this.sourceNode.ID,
    ]) as ActorConfig;
    if (config) {
      console.log(config);
      for (const [key, value] of Object.entries(config.connections)) {
        this.sourceNode.actor.send({
          type: "UPDATE_SOCKET",
          params: {
            name: key,
            side: "output",
            socket: {
              "x-connection": {
                ...this.sourceDefintion?.["x-connection"],
                [this.targetNode.id]: {
                  actorRef: this.targetNode.actor.ref,
                  key: value,
                },
              } as ConnectionConfigRecord,
            },
          },
        });
      }
    }
  }

  public setTargetValue(value: any) {
    this.targetValue = value;
  }

  public setSourceValue(value: any) {
    this.sourceValue = value;
  }

  public toJSON() {
    return {
      id: this.id,
      source: this.source,
      target: this.target,
      sourceOutput: this.sourceOutput,
      targetInput: this.targetInput,
    };
  }
}
